from .constants import (
    ENCAPSULATED_INTERFACE_TRANSPORT as ENCAPSULATED_INTERFACE_TRANSPORT,
    EXP_DETAILS as EXP_DETAILS,
    EXP_NONE as EXP_NONE,
    EXP_TXT as EXP_TXT,
    MB_CONNECT_ERR as MB_CONNECT_ERR,
    MB_ERR_TXT as MB_ERR_TXT,
    MB_EXCEPT_ERR as MB_EXCEPT_ERR,
    MB_NO_ERR as MB_NO_ERR,
    MB_RECV_ERR as MB_RECV_ERR,
    MB_SEND_ERR as MB_SEND_ERR,
    MB_SOCK_CLOSE_ERR as MB_SOCK_CLOSE_ERR,
    MB_TIMEOUT_ERR as MB_TIMEOUT_ERR,
    MEI_TYPE_READ_DEVICE_ID as MEI_TYPE_READ_DEVICE_ID,
    READ_COILS as READ_COILS,
    READ_DISCRETE_INPUTS as READ_DISCRETE_INPUTS,
    READ_HOLDING_REGISTERS as READ_HOLDING_REGISTERS,
    READ_INPUT_REGISTERS as READ_INPUT_REGISTERS,
    VERSION as VERSION,
    WRITE_MULTIPLE_COILS as WRITE_MULTIPLE_COILS,
    WRITE_MULTIPLE_REGISTERS as WRITE_MULTIPLE_REGISTERS,
    WRITE_READ_MULTIPLE_REGISTERS as WRITE_READ_MULTIPLE_REGISTERS,
    WRITE_SINGLE_COIL as WRITE_SINGLE_COIL,
    WRITE_SINGLE_REGISTER as WRITE_SINGLE_REGISTER,
)
from .utils import (
    byte_length as byte_length,
    set_bit as set_bit,
    valid_host as valid_host,
)
from _typeshed import Incomplete
from dataclasses import dataclass, field

logger: Incomplete

@dataclass
class DeviceIdentificationResponse:
    conformity_level: int = ...
    more_follows: int = ...
    next_object_id: int = ...
    objects_by_id: dict[int, bytes] = field(default_factory=dict)
    @property
    def vendor_name(self): ...
    @property
    def product_code(self): ...
    @property
    def major_minor_revision(self): ...
    @property
    def vendor_url(self): ...
    @property
    def product_name(self): ...
    @property
    def model_name(self): ...
    @property
    def user_application_name(self): ...

class ModbusClient:
    class _InternalError(Exception): ...

    class _NetworkError(_InternalError):
        code: Incomplete
        message: Incomplete
        def __init__(self, code, message) -> None: ...

    class _ModbusExcept(_InternalError):
        code: Incomplete
        def __init__(self, code) -> None: ...

    def __init__(
        self,
        host: str = "localhost",
        port: int = 502,
        unit_id: int = 1,
        timeout: float = 30.0,
        auto_open: bool = True,
        auto_close: bool = False,
    ) -> None: ...
    def __del__(self) -> None: ...
    @property
    def version(self): ...
    @property
    def last_error(self): ...
    @property
    def last_error_as_txt(self): ...
    @property
    def last_except(self): ...
    @property
    def last_except_as_txt(self): ...
    @property
    def last_except_as_full_txt(self): ...
    @property
    def host(self): ...
    @host.setter
    def host(self, value) -> None: ...
    @property
    def port(self): ...
    @port.setter
    def port(self, value) -> None: ...
    @property
    def unit_id(self): ...
    @unit_id.setter
    def unit_id(self, value) -> None: ...
    @property
    def timeout(self): ...
    @timeout.setter
    def timeout(self, value) -> None: ...
    @property
    def auto_open(self): ...
    @auto_open.setter
    def auto_open(self, value) -> None: ...
    @property
    def auto_close(self): ...
    @auto_close.setter
    def auto_close(self, value) -> None: ...
    @property
    def is_open(self): ...
    def open(self): ...
    def close(self) -> None: ...
    def custom_request(self, pdu): ...
    def read_coils(self, bit_addr, bit_nb: int = 1): ...
    def read_discrete_inputs(self, bit_addr, bit_nb: int = 1): ...
    def read_holding_registers(self, reg_addr, reg_nb: int = 1): ...
    def read_input_registers(self, reg_addr, reg_nb: int = 1): ...
    def read_device_identification(self, read_code: int = 1, object_id: int = 0): ...
    def write_single_coil(self, bit_addr, bit_value): ...
    def write_single_register(self, reg_addr, reg_value): ...
    def write_multiple_coils(self, bits_addr, bits_value): ...
    def write_multiple_registers(self, regs_addr, regs_value): ...
    def write_read_multiple_registers(
        self, write_addr, write_values, read_addr, read_nb: int = 1
    ): ...
    def on_tx_rx(self, frame: bytes, is_tx: bool): ...
